<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/batman.png"><link rel="icon" href="/img/batman.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="description" content="关于动态规划问题的定义与应用"><meta name="author" content="Tars-knock"><meta name="keywords" content="技术笔记 日常随笔"><title>经典算法--动态规划 - Tars Blog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"www.tars-knock.cn",root:"/",version:"1.8.10",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,baidu:"000c8623e418a244bb21d401c84cbfc3",google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"zldqPvhiQPhi7OHlqIQKsssf-gzGzoHsz",app_key:"seqt5G6b8y8z6p0zo03uR31L",server_url:"https://zldqpvhi.lc-cn-n1-shared.com"}}}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><header style="height:45vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>Tars blog</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-books"></i> 文章</a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档 </a><a class="dropdown-item" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类 </a><a class="dropdown-item" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></div></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(/img/sfln.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="经典算法--动态规划"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-03-19 12:57" pubdate>2021年3月19日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 2.1k 字 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">经典算法--动态规划</h1><p class="note note-info">本文最后更新于：2 个月前</p><div class="markdown-body"><p>动态规划(dynamic programming)问题与分治问题相似，是通过结合子问题的解来求解原问题的算法。</p><blockquote><p>programming指的是一种表格法而不是计算机程序，也暗含了动态规划的基本思想</p></blockquote><h2 id="动态规划与分治算法的异同"><a href="#动态规划与分治算法的异同" class="headerlink" title="动态规划与分治算法的异同"></a>动态规划与分治算法的异同</h2><p>动态规划与分治算法同样是将复杂的原问题分解为若干小问题进行求解；<br>但是分治算法是将原问题分成互不相关的子问题；而动态规划算法的子问题往往是一环套一环，求解后面的问题时需要用到前面的答案。</p><h2 id="动态规划问题的特征"><a href="#动态规划问题的特征" class="headerlink" title="动态规划问题的特征"></a>动态规划问题的特征</h2><p>动态规划方法常常用来求解<strong>最优化问题</strong>。这类问题及其子问题往往有许多个可行解，我们希望找到其最优解（最小值或最大值），于是就需要每一个小问题都求出最优解，这些小问题的取值又会相互制约；此时就需要使用动态规划算法。</p><p>所以适合应用动态规划方法求解的最优化问题一般具有几个重要特征：</p><ul><li><p><strong>最优子结构</strong></p><blockquote><p>在动态规划方法中,我们通常自底向上地使用最优子结构。也就是说,首先求得子向题的最优解,然后求原问题的最优解。在求解原问题过程中,我们需要在涉及的子问题中做出选择,选出能得到原问题最优解的子问题。原问题最优解的代价通常就是子问题最优解的代价再加上由此次选择直接产生的代价。</p></blockquote></li><li><p><strong>子问题重叠</strong></p><blockquote><p>适合用动态规划方法求解的最优化问题应该具备的第二个性质是子问题空间必须足够“小”，即问题的递归算法会反复地求解相同的子问题,而不是一直生成新的子问题。一般来讲,不同子问题的总数是输入规模的多项式函数为好。如果递归算法反复求解相同的子问题,我们就称最优化问题具有重叠子问题)性质。</p></blockquote><p><strong>注意</strong>：子问题重叠并不代表子问题可以不离散；即子问题之间不能相互影响，例如下面的背包问题，如果选择了吉他之后音响所占重量会更轻，那么这个问题无法使用动态规划解决</p></li><li><p><strong>只求结果而不求过程</strong><br>动态规划过程中往往会将每个子问题的结果抹掉，最后得到的只是最优解的数值<strong>；这一点在算法题中尤为明显</strong>，往往只是询问最大结果是多少而不问如何取得最大成果</p></li></ul><h2 id="动态规划食用方法"><a href="#动态规划食用方法" class="headerlink" title="动态规划食用方法"></a>动态规划食用方法</h2><p>经典例子：背包问题<br>有一个可装4磅重量的背包，可供容纳的物品有：[磅数， 价值]，音响[4,3000],笔记本电脑[3,2000],吉他[1,1500]。相同物品只能装一个，请问如何装能使背包的价值最高？</p><p>动态规划算法都从网格开始，这个问题的网格如下</p><table><thead><tr><th>可选择的商品\容量为1~4的背包</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>吉他</td><td>容纳物品价值</td><td></td><td></td><td></td></tr><tr><td>音响</td><td></td><td></td><td></td><td></td></tr><tr><td>笔记本电脑</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>为了简单，填表顺序为从左上到右下，引出另一个重要概念<strong>状态转移方程</strong> <del>人话讲就是填表方程</del><br>这个表的状态转移方程就是cell [i] [j] = max(cell [i-1] [j], 当前行物品价值+装一个当前行物品后剩余空间价值）<br><em>i为行 j为列</em><br>就可以得到这样的一张表格</p><table><thead><tr><th></th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>吉他</td><td>1500</td><td>1500</td><td>1500</td><td>1500</td></tr><tr><td>音响</td><td>1500</td><td>1500</td><td>1500</td><td><strong>3000</strong></td></tr><tr><td>笔记本电脑</td><td>1500</td><td>1500</td><td><strong>2000</strong></td><td><strong>3500</strong></td></tr></tbody></table><p>所以最终结果就是3500，一个吉他一个笔记本。</p><h2 id="Talk-is-cheap-show-me-the-code"><a href="#Talk-is-cheap-show-me-the-code" class="headerlink" title="Talk is cheap ,show me the code"></a>Talk is cheap ,show me the code</h2><p>先来一个简单一点的</p><h3 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h3><blockquote><p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。</p><p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p><p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：cost = <span class="hljs-comment">[10, 15, 20]</span><br>输出：15<br>解释：最低花费是从 cost<span class="hljs-comment">[1]</span> 开始，然后走两步即可到阶梯顶，一共花费 15 。<br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-cost-climbing-stairs">使用最小花费爬楼梯</a></p></blockquote><p>表格如图，表中数据为到达该点所需最小体力<br><img src="D8F4F10C1F9781ADDF1625C9A74CD6DE.png" srcset="/img/loading.gif" lazyload alt="D8F4F10C1F9781ADDF1625C9A74CD6DE" style="zoom:25%"></p><p>状态转移方程: cell [i] [1] = min(cell [i-1] [1]+cost[i], cell [i-1] [2]+cost [i])<br>cell [i] [2] = min(cell [i-2] [1]+cost[i], cell [i-2] [2]+cost [i])</p><p><em>Tips:由于填表时最多只用到三行，所以可以构建一个只有三行的表循环使用，减少空间占用</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] cost)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = cost.length;<br>        <span class="hljs-comment">// int[][] dp = new int[len+1][2];</span><br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>];	<span class="hljs-comment">//使用了压缩空间的dp表</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = cost[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = cost[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = cost[<span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i&lt;len;i++)&#123;<br>            dp[i%<span class="hljs-number">3</span>][<span class="hljs-number">0</span>] = Math.min(dp[(i-<span class="hljs-number">1</span>)%<span class="hljs-number">3</span>][<span class="hljs-number">0</span>], dp[(i-<span class="hljs-number">1</span>)%<span class="hljs-number">3</span>][<span class="hljs-number">1</span>])+cost[i];<br>            dp[i%<span class="hljs-number">3</span>][<span class="hljs-number">1</span>] = Math.min(dp[(i-<span class="hljs-number">2</span>)%<span class="hljs-number">3</span>][<span class="hljs-number">0</span>], dp[(i-<span class="hljs-number">2</span>)%<span class="hljs-number">3</span>][<span class="hljs-number">1</span>])+cost[i];<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> one = Math.min(dp[(len-<span class="hljs-number">1</span>)%<span class="hljs-number">3</span>][<span class="hljs-number">0</span>], dp[(len-<span class="hljs-number">1</span>)%<span class="hljs-number">3</span>][<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">int</span> another = Math.min(dp[(len-<span class="hljs-number">2</span>)%<span class="hljs-number">3</span>][<span class="hljs-number">0</span>], dp[(len-<span class="hljs-number">2</span>)%<span class="hljs-number">3</span>][<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">return</span> Math.min(one, another);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h3><blockquote><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">买卖股票的最佳时机</a></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出，最大利润 = 6-1 =<span class="hljs-number"> 5 </span>。<br>    注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br></code></pre></td></tr></table></figure></blockquote><p>可以得到如图的表<br><img src="1C89DF8161417341931EC3B818B892A2.png" srcset="/img/loading.gif" lazyload alt="1C89DF8161417341931EC3B818B892A2" style="zoom:33%"></p><p>状态转移方程为cell[i] [1] = max(cell [i-1] [1], -price[i])<br>cell[i] [2] = max(cell[i-1] [1] + price[i] , cell[i-1] [2])</p><p>这里最难想到的是列表的方法，也是每个题中变数最大的地方，要勤加观察</p><p><em>Tips: 由于卖出股票之后不可以再次买入，所以求解 持有 状态时无需用到 不持有 状态的值</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = prices.length;<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;len;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+prices[i]);<br>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], -prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[len-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="经典：连续子数组的组大和"><a href="#经典：连续子数组的组大和" class="headerlink" title="经典：连续子数组的组大和"></a>经典：连续子数组的组大和</h3><blockquote><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入: nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出: 6<br>解释: 连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6。<br></code></pre></td></tr></table></figure></blockquote><p>这个问题列出的表格如下</p><table><thead><tr><th>i</th><th>-2</th><th>1</th><th>-3</th><th>4</th><th>-1</th><th>2</th><th>1</th><th>-5</th><th>4</th></tr></thead><tbody><tr><td><strong>以i位结尾的最大子数组和</strong></td><td>-2</td><td>1</td><td>-2</td><td>4</td><td>3</td><td>5</td><td>6</td><td>-1</td><td>3</td></tr></tbody></table><p>其中最难想到的就是表中填的数字，和一般的动态规划有一定的差异，想到这个表之后状态转移方程也就是简而易见了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">int</span> result = nums[<span class="hljs-number">0</span>] ;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt;nums.length;i++)&#123;<br>            nums[i] = nums[i-<span class="hljs-number">1</span>]&gt;<span class="hljs-number">0</span>?nums[i-<span class="hljs-number">1</span>]+nums[i]:nums[i];<br>            result = Math.max(result, nums[i]);<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>动态规划类问题比较难的部分就是灵活变通，找出最适合解决问题的列表方法和状态转移方程。</p><p>切记不能拘泥于一种想法不知变通。</p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/2021032284d5/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">单自由度树莓派相机云台</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/20210315f96a/"><span class="hidden-mobile">Hello world</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments" lazyload><script type="text/javascript">Fluid.utils.loadComments("#comments",(function(){var t=document.documentElement.getAttribute("data-user-color-scheme");t="dark"===t?"github-dark":"github-light",window.UtterancesThemeLight="github-light",window.UtterancesThemeDark="github-dark";var e=document.createElement("script");e.setAttribute("src","https://utteranc.es/client.js"),e.setAttribute("repo","Tars-knock/Tars-knock.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("label","utterances"),e.setAttribute("theme",t),e.setAttribute("crossorigin","anonymous"),document.getElementById("comments").appendChild(e)}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="X"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a><div><span id="timeDate">载入天数...</span><script src="/js/duration.js"></script></div></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script defer src="/js/leancloud.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/js/local-search.js"></script><script>$("#local-search-input").on("click",(function(){searchFunc("/local-search.xml","local-search-input","local-search-result")})),$("#modalSearch").on("shown.bs.modal",(function(){$("#local-search-input").focus()}))</script><script defer>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?000c8623e418a244bb21d401c84cbfc3";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script src="/js/boot.js"></script></body></html>