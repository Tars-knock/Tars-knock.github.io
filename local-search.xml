<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>深度优先搜索</title>
    <link href="/20210604e9a6/"/>
    <url>/20210604e9a6/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二分查找(旋转数组的最小值)</title>
    <link href="/202106044658/"/>
    <url>/202106044658/</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>二分查找是一种应用了分治思想的查找算法，<em>基本思想十分简单，只是对于一些特殊问题有一些小点需要注意</em>，将在后面例题中介绍。</p><h2 id="应用范围"><a href="#应用范围" class="headerlink" title="应用范围"></a>应用范围</h2><p>在<strong>顺序存储</strong>的数据集中查找某个目标值</p><blockquote><p>顺序存储可以是升序降序，一些特殊情况甚至可以是部分有序（比如即将介绍的旋转数组问题）</p></blockquote><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>此处以升序的数据集作为例子，将数据集中间位置的值与目标值进行比较，如果比目标值大则将尾指针移动至中间位置，对于头尾指针之间的数据继续进行二分查找；如果中间位置的值比目标值小则将头指针移动至数据集中间。时间复杂度可以做到$O(n) = log_2n$。</p><h2 id="例题：旋转数组问题"><a href="#例题：旋转数组问题" class="headerlink" title="例题：旋转数组问题"></a>例题：旋转数组问题</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p><p>示例 1：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[3,4,5,1,2]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[2,2,2,0,1]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这个数组即前面提到的“部分有序”，是升序 但又不完全是，由于需要查找的元素所处位置的特殊性而且以查找元素为分界线前后元素均有序，所以可以使用二分查找进行解题。</p><h3 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] numbers)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i,j,m;<br>        j = numbers.length-<span class="hljs-number">1</span>;<br>        i = <span class="hljs-number">0</span>;<br>        m = (i+j)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span>(i!=j)&#123;<br>            <span class="hljs-keyword">if</span>(numbers[m]&lt;numbers[j])&#123;<br>               j = m;<br>               m = (i+j)/<span class="hljs-number">2</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(numbers[m]&gt;numbers[j])&#123;<br>                i = m+<span class="hljs-number">1</span>;<br>                m = (i+j)/<span class="hljs-number">2</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(numbers[m] == numbers[j])&#123;<br>                j = j-<span class="hljs-number">1</span>;<br>                m = (i+j)/<span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> numbers[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一个小点"><a href="#一个小点" class="headerlink" title="一个小点"></a>一个小点</h3><p>这个题解前面大部分就是基本的二分查找，但是：在一些特殊情况下，如本题的</p><p>第16行处 遇到重复值的情况如何处理:</p><ol><li><p><strong>当 x&lt;jx &lt; jx&lt;j 时：</strong> 易得执行 j=j−1j = j - 1j=j−1 后，旋转点 xxx 仍在区间 [i,j][i, j][i,j] 内。</p></li><li><p><strong>当 x=jx = jx=j 时：</strong> 执行 j=j−1j = j - 1j=j−1 后越过（丢失）了旋转点 xxx ，但最终返回的元素值 nums[i]仍等于旋转点值 nums[x] 。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>能看懂手语的机器狗 展示视频</title>
    <link href="/20210527193c/"/>
    <url>/20210527193c/</url>
    
    <content type="html"><![CDATA[<div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","video":{"url":"/video/综合展示部分.mp4","pic":"/img/dog.jpg"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器人</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/20210512f171/"/>
    <url>/20210512f171/</url>
    
    <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集是一种树形的<strong>数据结构</strong>，顾名思义，它用于处理一些不交集的 <strong>合并</strong> 及 <strong>查询</strong> 问题。 它支持两种操作：</p><ul><li><a href="#h3">查找（Find）：确定某个元素处于哪个子集；</a></li><li><a href="#bing">合并（Union）：将两个子集合并成一个集合。</a></li></ul><h2 id="适用并查集的情况"><a href="#适用并查集的情况" class="headerlink" title="适用并查集的情况"></a>适用并查集的情况</h2><p>已知一堆叶子，只知道每个叶子的父节点。如何查找每个叶子的祖先节点(判断两个点是否属于同一集合）；如何将所有叶子合并进一棵树。<br>这种问题就适合使用并查集进行叶子的整理，查找每个叶子究竟属于哪一棵树。</p><p>方便起见使用一个一维数组来储存每个叶子节点极其父节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] parent;  parent[a] = b; <span class="hljs-comment">//代表a的父亲节点是b，并规定祖先的父亲节点是自己。 </span><br></code></pre></td></tr></table></figure><p>再贴一个来自<a href="https://oi-wiki.org/ds/dsu/">OI-wiki</a>的接地气解释</p><blockquote><p>通俗地讲一个故事：几个家族进行宴会，但是家族普遍长寿，所以人数众多。由于长时间的分离以及年龄的增长，这些人逐渐忘掉了自己的亲人，只记得自己的爸爸是谁了，而最长者（称为「祖先」）的父亲已经去世，他只知道自己是祖先。</p><p>宴会上，一个家族的祖先突然对另一个家族说：我们两个家族交情这么好，不如合成一家好了。另一个家族也欣然接受了。</p></blockquote><h2 id="并查集的“查”"><a href="#并查集的“查”" class="headerlink" title="并查集的“查”"></a>并查集的“查”</h2><div id = "h3"><p>解决方法并没有那么难想，只要一个一个叶子往前推，直到找到祖先叶子为止。所以可以使用递归思想。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] parent;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-comment">// 寻找x的祖先</span><br>  <span class="hljs-keyword">if</span> (parent[x] == x)  <span class="hljs-comment">// 如果x是祖先则返回</span><br>    <span class="hljs-keyword">return</span> x;<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> find(parent[x]);  <span class="hljs-comment">// 如果不是则x的爸爸问x的爷爷</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>上面的查确实可以查找到祖先，但是要经过所有的叶子节点，效率明显不高。所以如果只想找到每个叶子的祖先，只需要每个叶子都成为祖先的直接子节点，即parent[a]直接储存a的祖先，这样就可以达到路径压缩减小时间复杂度的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] parent;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-comment">// 寻找x的祖先</span><br>  <span class="hljs-keyword">if</span> (parent[x] == x)&#123;  <span class="hljs-comment">// 如果x是祖先则返回</span><br>    <span class="hljs-keyword">return</span> x;<br>  &#125;<br>  <span class="hljs-keyword">else</span>&#123;<br>    parent[x] = find(parent[x]);  <span class="hljs-comment">// 查找x的祖先直到找到代表,顺手路径压缩</span><br>    <span class="hljs-keyword">return</span> find(parent[x]);  <span class="hljs-comment">// 如果不是则x的爸爸问x的爷爷</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="并查集的“并”"><a href="#并查集的“并”" class="headerlink" title="并查集的“并”"></a>并查集的“并”</h2><div id = "bing"><p>将已知的几棵树合在一起成为一棵树，最简单粗暴的方法就是使一棵树的祖先节点成为另一棵树祖先节点的子节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unionSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>  <span class="hljs-comment">// x 与 y 所在树合并</span><br>  x = find(x);<br>  y = find(y);<br>  parent[x] = y;  <span class="hljs-comment">// 把 x 的祖先变成 y 的祖先的儿子</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="启发式合并（按秩合并）"><a href="#启发式合并（按秩合并）" class="headerlink" title="启发式合并（按秩合并）"></a>启发式合并（按秩合并）</h3><p>因为并查集这个数据结构只支持集合的合并与查询操作，所以合并时选择将点数更少深度更小的树移动为其他树的字数可以使得查找时的最坏时间复杂度更低。</p><p>当然并不是每一次都能找到点数既是最小深度又是最小的树，只能使用一个特征作为选取移动树的参考。</p><p>。。。。。后续待补充</p><h2 id="java-中的并查集"><a href="#java-中的并查集" class="headerlink" title="java 中的并查集"></a>java 中的并查集</h2><p>Java嘛，面向对象语言，这种数据结构必然得给他封装成一个类日后用起来才方便。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] parent;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            parent[i] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index1, <span class="hljs-keyword">int</span> index2)</span> </span>&#123;<br>        parent[find(index2)] = find(index1);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (parent[index] != index) &#123;<br>            parent[index] = find(parent[index]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[index];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="经典例题"><a href="#经典例题" class="headerlink" title="经典例题"></a>经典例题</h2><p>冗余连接</p><blockquote><p>在本问题中, 树指的是一个连通且无环的无向图。</p><p>输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p><p>结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。</p><p>返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/redundant-connection">https://leetcode-cn.com/problems/redundant-connection</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>示例 1：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">输入: [[1,2], [1,3], [2,3]]<br>输出: [2,3]<br>解释: 给定的无向图为:<br>  1<br> / \<br>2 - 3<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]<br>输出: [1,4]<br>解释: 给定的无向图为:<br>5 - 1 - 2<br>    |   |<br>    4 - 3<br></code></pre></td></tr></table></figure><p>注意:</p><pre><code>输入的二维数组大小在 3 到 1000。二维数组中的整数在1到N之间，其中N是输入数组的大小。</code></pre><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] findRedundantConnection(<span class="hljs-keyword">int</span>[][] edges) &#123;<br>        <span class="hljs-keyword">int</span>[] parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[edges.length+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;edges.length+<span class="hljs-number">1</span>;i++)    parent[i] = i;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;edges.length;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(find(parent, edges[i][<span class="hljs-number">0</span>])!= find(parent, edges[i][<span class="hljs-number">1</span>]))<br>                <span class="hljs-comment">//在冗余的边出现之前，两个点已经出现在同一集合了</span><br>            &#123;<br>                union(parent, edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>]);<br>            &#125;<br>            <span class="hljs-comment">//如果一个边的两个端点已经是同一集合的了，这条边就是多余的，返回</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> edges[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//**</span><br>    这个方法就是并查集当中的“查”，查找祖先并返回；<br>    其中<span class="hljs-keyword">else</span>中的语句还顺便进行了路径缩短，使得所有同一家族的元素指向的均为最高级的祖先<br>     */<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] parent, <span class="hljs-keyword">int</span> index)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(parent[index]==index)    <span class="hljs-keyword">return</span> index;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> parent[index]=find(parent, parent[index]);<br>    &#125;<br>    <span class="hljs-comment">//**</span><br>    这个方法就是并查集当中的“并”， 可以将一条新的树枝加入原有的图中<br>    */<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] union(<span class="hljs-keyword">int</span>[] parent, <span class="hljs-keyword">int</span> index1, <span class="hljs-keyword">int</span> index2)<br>    &#123;<br>        parent[find(parent, parent[index2])] = find(parent, index1);<br>        <span class="hljs-keyword">return</span> parent;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span>[][] test = &#123;&#123;<span class="hljs-number">1.2</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;&#125;;<br>        System.out.println(findRedundantConnection(test).toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>小弟当初初入力扣就遇到并查集月，每天的每日一题都是并查集……<br>跟着做了几道本来以为自己可能永远也忘不了这个知识点了，<br>结果几个月之后看见群里有大佬讨论这东西发现自己忘光光了……<br>遂作此篇🤐</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb学习笔记</title>
    <link href="/20210506418d/"/>
    <url>/20210506418d/</url>
    
    <content type="html"><![CDATA[<h3 id="新版-web-xml"><a href="#新版-web-xml" class="headerlink" title="新版 web.xml"></a>新版 web.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">metadata-complete</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="servlet的依赖包"><a href="#servlet的依赖包" class="headerlink" title="servlet的依赖包"></a>servlet的依赖包</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="编写servlet的映射"><a href="#编写servlet的映射" class="headerlink" title="编写servlet的映射"></a>编写servlet的映射</h3><p><em>这部分内容也写在web.xml中</em></p><h4 id="为什么要映射"><a href="#为什么要映射" class="headerlink" title="为什么要映射"></a>为什么要映射</h4><p>我们写的是Java程序，而Javaweb需要浏览器来进行访问，而浏览器要链接的是web服务器，所以要在web服务器中注册我们所写的servlet，同时还需要给一个浏览器可以访问的路径（url）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  注册servlet--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>cn.tars.servlet.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-comment">&lt;!--  servlet的请求路径--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-comment">&lt;!--    此时输入hello就会走servlet--&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="servlet中的mapping"><a href="#servlet中的mapping" class="headerlink" title="servlet中的mapping"></a>servlet中的mapping</h4><p>这个值是用于指定访问相应Java程序的URL的，可以使用通配符*。<br>所以，可以有多个url指向一个java程序等等花式操作；（这也是为什么要进行映射二不是直接在域名中使用.class文件名的原因之一）<br>同时，当通配符与精准域名冲突时（如/hello与/*），默认会使用精确的域名（即/hello），也就是越精确优先级越高。</p><h4 id="tomcat查找相应class文件的过程"><a href="#tomcat查找相应class文件的过程" class="headerlink" title="tomcat查找相应class文件的过程"></a>tomcat查找相应class文件的过程</h4><ol><li>当浏览器首次通过localhost:8080/XXXX/hello时，需要加载相应的servlet类</li><li>首先参考web.xml，找到 <url-pattern>子元素的值为/hello的<servlet-mapping>元素</li><li>读取<servlet-mapping>元素的<servlet-name>的子元素的值，由此确定Servlet的类名为hello</li><li>找到<servlet-name>子元素的值为hello的<servlet>元素</li><li>读取该<servlet>元素的<servlet-class>子元素的值，由此确定Servlet的类名为cn.tars.servlet.HelloServlet</li><li>去/WEB-INF/classes/cn.tars.servlet目录下查找HelloServlet.class文件</li></ol><h4 id="servlet元素的子元素"><a href="#servlet元素的子元素" class="headerlink" title="servlet元素的子元素"></a>servlet元素的子元素</h4><p><img src="%E5%88%A0.png" alt="删"></p><h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><ul><li><p>Java包名是不允许有特殊符号的，idea会自动将不合法的包名视为普通文件夹且没有提示</p><blockquote><p>基础不牢地动山摇😥</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaweb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优化的swing文本框</title>
    <link href="/2021040393ff/"/>
    <url>/2021040393ff/</url>
    
    <content type="html"><![CDATA[<h1 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.swing.*;<br><span class="hljs-keyword">import</span> java.awt.event.FocusAdapter;<br><span class="hljs-keyword">import</span> java.awt.event.FocusEvent;<br><br><span class="hljs-comment">/**优化的swing 输入框</span><br><span class="hljs-comment"> * 获取鼠标焦点之后可以清除提示文字</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Tars</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myTextField</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JTextField</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> String text;<br><br><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">myTextField</span><span class="hljs-params">(String text, <span class="hljs-keyword">int</span> columns)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>(text, columns);<br>            <span class="hljs-keyword">this</span>.text = text;<br>            <span class="hljs-keyword">this</span>.addFocusListener(<span class="hljs-keyword">new</span> FocusAdapter() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">focusGained</span><span class="hljs-params">(FocusEvent e)</span> </span>&#123;<br>                    <span class="hljs-keyword">super</span>.focusGained(e);<br>                    <span class="hljs-keyword">if</span>(myTextField.<span class="hljs-keyword">this</span>.getText().equals(myTextField.<span class="hljs-keyword">this</span>.text))    myTextField.<span class="hljs-keyword">this</span>.setText(<span class="hljs-string">&quot;&quot;</span>);<br>                &#125;<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">focusLost</span><span class="hljs-params">(FocusEvent e)</span> </span>&#123;<br>                    <span class="hljs-keyword">super</span>.focusLost(e);<br>                    <span class="hljs-keyword">if</span>(myTextField.<span class="hljs-keyword">this</span>.getText().isEmpty())    myTextField.<span class="hljs-keyword">this</span>.setText(myTextField.<span class="hljs-keyword">this</span>.text);<br>                &#125;<br>            &#125;);<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>用过才知道swing真的是难用，一个文本框连提示文字都不给；</p><p>所以我直接重写了JTextField类，直接给类注册了两个窗口监听器，检测到文本框获取焦点之后便自己清除里面的示例文字，如果用户没有输入就在失去焦点时恢复示例文字。</p><h1 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h1><p>swing是真滴难用😩</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>swing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java虚拟机内存管理总结</title>
    <link href="/202103247953/"/>
    <url>/202103247953/</url>
    
    <content type="html"><![CDATA[<h2 id="java内存区域分配"><a href="#java内存区域分配" class="headerlink" title="java内存区域分配"></a>java内存区域分配</h2><p><img src="image-20210324204216125.png" alt="一张图 简洁明了"></p><ul><li><p>线程私有数据区</p><ul><li><p>程序计数器</p><blockquote><p>可以看成是当前线程所执行的字节码的行号指示器<em>唯一一个不会产生任何OOM情况的区域</em></p></blockquote></li><li><p>java虚拟机栈</p><ul><li>生命周期与线程相同</li><li>储存单位为<strong>栈帧</strong>；每个方法执行时创建一个，储存<strong>局部变量表</strong>，<strong>操作数栈</strong>，<strong>动态链接</strong>，<strong>方法出口</strong>，等信息；</li><li>方法开始执行时对应的栈帧入栈，方法执行结束对应的栈帧出栈</li></ul></li><li><p>本地方法栈</p><blockquote><p>与虚拟机栈类似，只是服务于虚拟机使用到的本地方法，对于具体的实现方法没有要求，HotSpot等虚拟机甚至将其与虚拟机栈合二为一</p></blockquote></li></ul></li><li><p>线程共享数据区</p><ul><li><p>java堆</p><blockquote><p><em>几乎</em>所有对象实例以及数组都要在堆上分配</p><p>JIT编译器、标量替换技术等可能会使对象分配至其他区域</p></blockquote></li><li><p>方法区</p><blockquote><p>储存运行时常量池、<strong>已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong></p></blockquote></li></ul></li></ul><h2 id="java垃圾收集"><a href="#java垃圾收集" class="headerlink" title="java垃圾收集"></a>java垃圾收集</h2><h3 id="垃圾的判定"><a href="#垃圾的判定" class="headerlink" title="垃圾的判定"></a>垃圾的判定</h3><ul><li><p>引用计数法</p><blockquote><p>维护一个引用计数器，对象每被引用一次计数器就+1；</p><p>缺点是无法识别循环引用，难以做到线程同步；java并未采用</p></blockquote></li><li><p>可达性分析算法</p><blockquote><p>以“GC  Roots”为起点进行搜索，如果对象不可达便认为可回收<br>可作为GC Roots 的对象：</p><ul><li>虚拟机栈（本地方法栈）栈帧局部变量表中引用的对象</li><li>方法区中静态属性引用的对象</li><li>方法区中常量引用的对象</li></ul></blockquote></li></ul><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>首先使用可达性算法将所有可回收的对象进行标记，之后进行回收</p><p>缺点：效率低、产生空间碎片</p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>将内存分为两个区域实际使用时在一个区域中分配对象；当这个区域满后再将所有可用对象复制进另一个区域，袁曲宇清空。</p><p>实际实现中往往是将内存分为一个较大的Eden空间和两个较小的Survivor空间，只使用Eden和一块Survivor，回收时一次性将两块空间中的活对象复制进空闲的Survivor。<em>HotSpot默认Eden与Survivor是8:1</em>；当Survivor空间不足时还需要依赖其他内存（老年代）来进行分配担保。</p><p>缺点：对象存活率较高时效率变低、需要担保</p><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>标记过程与标记-清除算法相同，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活对象向一端移动，然后直接清理边界以外的内存。</p><h4 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h4><p>虚拟机将java堆分为新生代与老年代，目的是便于针对不同的区域使用不同的收集算法；新生代中的对象存活率较低，所以可以使复制算法；老年代中对象存活率高且没有担保，所以要用标记-清除或者标记-整理算法。</p><h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><ul><li><p>对象优先在Eden分配</p></li><li><p>大对象直接进入老年代</p></li><li><p>长期存活的对象进入老年代</p></li><li><p>动态对象年龄判定</p><blockquote><p>在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半,年龄大于或等于该年龄的对象就可以直接进入老年代,无须等到MaxTenuringThreshold中要求的年龄</p></blockquote></li><li><p>空间分配担保</p><blockquote><p>在发生Minor GC之前,虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间,如果这个条件成立,那么Minor GC可以确保是安全的。如果不成立,则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许,那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小,如果大于,将尝试着进行一次Minor GC,尽管这次Minor GC是有风险的;如果小于,或者HandlePromotionFailure设置不允许冒险,那这时也要改为进行一次Full GC</p></blockquote></li></ul><h3 id="具体的垃圾收集器"><a href="#具体的垃圾收集器" class="headerlink" title="具体的垃圾收集器"></a>具体的垃圾收集器</h3><img src=" image-20210324233901970.png" alt="垃圾收集器概览" style="zoom:50%;" /><table><thead><tr><th></th><th>serial</th><th>ParNew</th><th>Parallel Scavenge</th><th>serial Old</th><th>Parallel Old</th><th>CMS</th><th><del>垃圾一号</del>G1</th></tr></thead><tbody><tr><td>线程</td><td>单线程</td><td>多行程</td><td>多线程</td><td>单线程</td><td>多线程</td><td>仅初始标记单线程</td><td>仅初始标记单线程</td></tr><tr><td>并发</td><td>否</td><td>否</td><td>否</td><td>否</td><td>否</td><td>仅初始标记、重新标记不并发</td><td>仅并发标记并发</td></tr><tr><td>特点</td><td></td><td>并行版serial</td><td>追求更高吞吐量</td><td>老年代版serial</td><td>老年代版Parallel Scavenge</td><td>追求最短停顿时间</td><td>次时代垃圾收集器</td></tr></tbody></table><p>TIPS：</p><ul><li>并行（Parallel）指多条垃圾收集线程同时工作，但是还是需要暂停所有用户线程</li><li>并发（Concurrent）即垃圾收集线程与用户线程同时工作</li><li>吞吐量（Throughput）即 运行用户代码时间/（运行用户代码时间+垃圾收集时间）</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单自由度树莓派相机云台</title>
    <link href="/2021032284d5/"/>
    <url>/2021032284d5/</url>
    
    <content type="html"><![CDATA[<h1 id="来历"><a href="#来历" class="headerlink" title="来历"></a>来历</h1><p>给机器狗做一个头，简易的画了一个相机云台，算是学习solidworks之后的第一个像样的作品。</p><h1 id="渲染图"><a href="#渲染图" class="headerlink" title="渲染图"></a>渲染图</h1><p><img src="xrrj.JPG" alt="侧视"></p><p><img src="xrrj2.JPG" alt="正视"></p><h1 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h1><p><a href="/file/%E4%BE%A7%E6%9E%B6%E4%B8%A4%E4%B8%AA.SLDPRT">侧架</a></p><p><a href="/file/%E4%BA%91%E5%8F%B0%E5%BA%95%E5%BA%A7.SLDPRT">底座</a></p><p><a href="/file/%E7%9B%B8%E6%9C%BA%E6%94%AF%E6%9E%B6.SLDPRT">相机支架</a></p><p><a href="/file/%E6%8E%A5%E8%BF%91%E6%88%90%E5%93%81.SLDASM">装配体</a></p>]]></content>
    
    
    <categories>
      
      <category>机械设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>3D建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>经典算法--动态规划</title>
    <link href="/202103197cd4/"/>
    <url>/202103197cd4/</url>
    
    <content type="html"><![CDATA[<p>动态规划(dynamic programming)问题与分治问题相似，是通过结合子问题的解来求解原问题的算法。</p><blockquote><p>programming指的是一种表格法而不是计算机程序，也暗含了动态规划的基本思想</p></blockquote><h2 id="动态规划与分治算法的异同"><a href="#动态规划与分治算法的异同" class="headerlink" title="动态规划与分治算法的异同"></a>动态规划与分治算法的异同</h2><p>动态规划与分治算法同样是将复杂的原问题分解为若干小问题进行求解；<br>但是分治算法是将原问题分成互不相关的子问题；而动态规划算法的子问题往往是一环套一环，求解后面的问题时需要用到前面的答案。</p><h2 id="动态规划问题的特征"><a href="#动态规划问题的特征" class="headerlink" title="动态规划问题的特征"></a>动态规划问题的特征</h2><p>动态规划方法常常用来求解<strong>最优化问题</strong>。这类问题及其子问题往往有许多个可行解，我们希望找到其最优解（最小值或最大值），于是就需要每一个小问题都求出最优解，这些小问题的取值又会相互制约；此时就需要使用动态规划算法。</p><p>所以适合应用动态规划方法求解的最优化问题一般具有几个重要特征：</p><ul><li><p><strong>最优子结构</strong></p><blockquote><p>在动态规划方法中,我们通常自底向上地使用最优子结构。也就是说,首先求得子向题的最优解,然后求原问题的最优解。在求解原问题过程中,我们需要在涉及的子问题中做出选择,选出能得到原问题最优解的子问题。原问题最优解的代价通常就是子问题最优解的代价再加上由此次选择直接产生的代价。</p></blockquote></li><li><p><strong>子问题重叠</strong></p><blockquote><p>适合用动态规划方法求解的最优化问题应该具备的第二个性质是子问题空间必须足够“小”，即问题的递归算法会反复地求解相同的子问题,而不是一直生成新的子问题。一般来讲,不同子问题的总数是输入规模的多项式函数为好。如果递归算法反复求解相同的子问题,我们就称最优化问题具有重叠子问题)性质。</p></blockquote><p><strong>注意</strong>：子问题重叠并不代表子问题可以不离散；即子问题之间不能相互影响，例如下面的背包问题，如果选择了吉他之后音响所占重量会更轻，那么这个问题无法使用动态规划解决</p></li><li><p><strong>只求结果而不求过程</strong><br>动态规划过程中往往会将每个子问题的结果抹掉，最后得到的只是最优解的数值<strong>；这一点在算法题中尤为明显</strong>，往往只是询问最大结果是多少而不问如何取得最大成果</p></li></ul><h2 id="动态规划食用方法"><a href="#动态规划食用方法" class="headerlink" title="动态规划食用方法"></a>动态规划食用方法</h2><p>经典例子：背包问题<br>有一个可装4磅重量的背包，可供容纳的物品有：[磅数， 价值]，音响[4,3000],笔记本电脑[3,2000],吉他[1,1500]。相同物品只能装一个，请问如何装能使背包的价值最高？</p><p>动态规划算法都从网格开始，这个问题的网格如下</p><table><thead><tr><th>可选择的商品\容量为1~4的背包</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>吉他</td><td>容纳物品价值</td><td></td><td></td><td></td></tr><tr><td>音响</td><td></td><td></td><td></td><td></td></tr><tr><td>笔记本电脑</td><td></td><td></td><td></td><td></td></tr></tbody></table><p> 为了简单，填表顺序为从左上到右下，引出另一个重要概念<strong>状态转移方程</strong>   <del>人话讲就是填表方程</del><br>这个表的状态转移方程就是cell [i] [j] = max(cell [i-1] [j], 当前行物品价值+装一个当前行物品后剩余空间价值）<br>    <em>i为行 j为列</em><br>就可以得到这样的一张表格</p><table><thead><tr><th></th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>吉他</td><td>1500</td><td>1500</td><td>1500</td><td>1500</td></tr><tr><td>音响</td><td>1500</td><td>1500</td><td>1500</td><td><strong>3000</strong></td></tr><tr><td>笔记本电脑</td><td>1500</td><td>1500</td><td><strong>2000</strong></td><td><strong>3500</strong></td></tr></tbody></table><p>所以最终结果就是3500，一个吉他一个笔记本。</p><h2 id="Talk-is-cheap-show-me-the-code"><a href="#Talk-is-cheap-show-me-the-code" class="headerlink" title="Talk is cheap ,show me the code"></a>Talk is cheap ,show me the code</h2><p>先来一个简单一点的</p><h3 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h3><blockquote><p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。</p><p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p><p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：cost = <span class="hljs-comment">[10, 15, 20]</span><br>输出：15<br>解释：最低花费是从 cost<span class="hljs-comment">[1]</span> 开始，然后走两步即可到阶梯顶，一共花费 15 。<br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs">使用最小花费爬楼梯</a></p></blockquote><p>表格如图，表中数据为到达该点所需最小体力<br><img src="D8F4F10C1F9781ADDF1625C9A74CD6DE.png" alt="D8F4F10C1F9781ADDF1625C9A74CD6DE" style="zoom:25%;" /></p><p>状态转移方程: cell [i] [1] = min(cell [i-1] [1]+cost[i], cell [i-1] [2]+cost [i])<br>cell [i] [2] = min(cell [i-2] [1]+cost[i], cell [i-2] [2]+cost [i]) </p><p><em>Tips:由于填表时最多只用到三行，所以可以构建一个只有三行的表循环使用，减少空间占用</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] cost)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = cost.length;<br>        <span class="hljs-comment">// int[][] dp = new int[len+1][2];</span><br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>];<span class="hljs-comment">//使用了压缩空间的dp表</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = cost[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = cost[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = cost[<span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i&lt;len;i++)&#123;<br>            dp[i%<span class="hljs-number">3</span>][<span class="hljs-number">0</span>] = Math.min(dp[(i-<span class="hljs-number">1</span>)%<span class="hljs-number">3</span>][<span class="hljs-number">0</span>], dp[(i-<span class="hljs-number">1</span>)%<span class="hljs-number">3</span>][<span class="hljs-number">1</span>])+cost[i];<br>            dp[i%<span class="hljs-number">3</span>][<span class="hljs-number">1</span>] = Math.min(dp[(i-<span class="hljs-number">2</span>)%<span class="hljs-number">3</span>][<span class="hljs-number">0</span>], dp[(i-<span class="hljs-number">2</span>)%<span class="hljs-number">3</span>][<span class="hljs-number">1</span>])+cost[i];<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> one = Math.min(dp[(len-<span class="hljs-number">1</span>)%<span class="hljs-number">3</span>][<span class="hljs-number">0</span>], dp[(len-<span class="hljs-number">1</span>)%<span class="hljs-number">3</span>][<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">int</span> another = Math.min(dp[(len-<span class="hljs-number">2</span>)%<span class="hljs-number">3</span>][<span class="hljs-number">0</span>], dp[(len-<span class="hljs-number">2</span>)%<span class="hljs-number">3</span>][<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">return</span> Math.min(one, another);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h3><blockquote><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">买卖股票的最佳时机</a></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出，最大利润 = 6-1 =<span class="hljs-number"> 5 </span>。<br>    注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br></code></pre></td></tr></table></figure></blockquote><p>可以得到如图的表<br><img src="1C89DF8161417341931EC3B818B892A2.png" alt="1C89DF8161417341931EC3B818B892A2" style="zoom:33%;" /></p><p>状态转移方程为cell[i] [1] = max(cell [i-1] [1], -price[i])<br>cell[i] [2] = max(cell[i-1] [1] + price[i] , cell[i-1] [2])</p><p>这里最难想到的是列表的方法，也是每个题中变数最大的地方，要勤加观察</p><p><em>Tips: 由于卖出股票之后不可以再次买入，所以求解 持有 状态时无需用到 不持有 状态的值</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = prices.length;<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len][<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;len;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+prices[i]);<br>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], -prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[len-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="经典：连续子数组的组大和"><a href="#经典：连续子数组的组大和" class="headerlink" title="经典：连续子数组的组大和"></a>经典：连续子数组的组大和</h3><blockquote><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入: nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出: 6<br>解释: 连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6。<br></code></pre></td></tr></table></figure></blockquote><p>这个问题列出的表格如下</p><table><thead><tr><th>i</th><th>-2</th><th>1</th><th>-3</th><th>4</th><th>-1</th><th>2</th><th>1</th><th>-5</th><th>4</th></tr></thead><tbody><tr><td><strong>以i位结尾的最大子数组和</strong></td><td>-2</td><td>1</td><td>-2</td><td>4</td><td>3</td><td>5</td><td>6</td><td>-1</td><td>3</td></tr></tbody></table><p>其中最难想到的就是表中填的数字，和一般的动态规划有一定的差异，想到这个表之后状态转移方程也就是简而易见了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">int</span> result = nums[<span class="hljs-number">0</span>] ;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt;nums.length;i++)&#123;<br>            nums[i] = nums[i-<span class="hljs-number">1</span>]&gt;<span class="hljs-number">0</span>?nums[i-<span class="hljs-number">1</span>]+nums[i]:nums[i];<br>            result = Math.max(result, nums[i]);<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>动态规划类问题比较难的部分就是灵活变通，找出最适合解决问题的列表方法和状态转移方程。</p><p>切记不能拘泥于一种想法不知变通。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello world</title>
    <link href="/20210315f96a/"/>
    <url>/20210315f96a/</url>
    
    <content type="html"><![CDATA[<p>尝试用hexo在github上部署一个自己的静态博客；<br>开始记录一点东西</p><p>希望可以有所收获</p><p><img src="%E5%86%B0%E5%85%AC%E4%B8%BB%20%E5%A3%AB%E5%85%B5%20%E7%99%BD%E9%B8%BD%E5%92%8C%E5%9C%A3%E5%A0%82%20%E9%AC%BC%E5%88%804k%E5%8E%9F%E7%94%BB%E5%A3%81%E7%BA%B8_%E5%BD%BC%E5%B2%B8%E5%9B%BE%E7%BD%91.jpg" alt="图片测试"></p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
